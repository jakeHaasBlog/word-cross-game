#pragma once

#include "GL/glew.h"
#include "GLFW/glfw3.h"

#include <string>
#include <array>
#include <stack>

#include "engine/Texture.h"

#include "engine/Shader.h"

class Window {
public:
	static Window& getWindowInstance();

private:
	Window();

public:

	// renders the whole game onto the framebuffer, then renders the framebuffer over the window
	// updates delta time and update time
	// calculates FPS
	// runs an infinite loop until the window is closed
	// == DO NOT CALL THIS FUNCTION, IT IS ONLY CALLED IN SOURCE.CPP ==
	void mainUpdateLoop();

	// manually resize the window to whatever size you want in pixels
	void setSize(int width, int height);

	// for development purposes, the FPS, deltaTime, and updateTime are appended to the end of whatever title you set here
	void setTitle(const std::string& title);

	// this does nothing at the moment
	void setResolution(int width, int height);

	// in pixels
	int getWidth();

	// in pixels
	int getHeight();
	std::string getTitle();

	// in pixels
	int getFrameBufferWidth();

	// in pixels
	int getFrameBufferHeight();

	// returns the aspect ratio of the framebuffer, you probably want to look at ViewportManager::getAspectRatio() if you need the AR for rendering though
	float getAspectRatio();

	// based on the time between actually seeing frames, v-sync caps this to 60FPS (or whatever your monitor's refresh rate is)
	double getFrameRate();

	// example input: GLFW_KEY_W, GLFW_KEY_0, GLFW_KEY_RIGHT_BRACKET
	bool keyIsDown(int glfwKey);

	// in normalized device coodinates (-1.0 is furthest left, 1.0 is furthest right)
	float getMouseX();

	// in normalized device coodinates (-1.0 is furthest down, 1.0 is furthest up)
	float getMouseY();

	// closes the window, begins uninitializing the program
	void close();

	// returns the window handle generated by glfw
	GLFWwindow* getHandle();

	// Returns a texture of the entire screen, like a screenshot but this is updated every frame
	// You can use this to create after effects like inverting colors by using a custom shader or just regenerating the texture
	// ---> Do not modify this texture's resolution or everything will render incorrectly <---
	Texture& getFramebufferTexture();

	void setPostProcessingShaderDefault();
	void setPostProcessingShader(Shader& shader);

private:

	std::string title;
	GLFWwindow* windowHandle;

	void calculateFPS(); // called every exactly 10 frames 
	float fps;

	float mouseX, mouseY;
	static void keyCallback(GLFWwindow* wind, int key, int scancode, int action, int mods);
	static void charCallback(GLFWwindow* wind, unsigned int codepoint);
	static void mouseButtonCallback(GLFWwindow* wind, int button, int action, int mods);
	static void mouseMoveCallback(GLFWwindow* wind, double xPos, double yPos);
	static void windowResizeCallback(GLFWwindow* wind, int width, int height);

	Texture framebuffer;
	static bool framebufferResizeFlag;
	static int newFramebufferWidth, newFramebufferHeight;

	static int preferedFramebufferWidth;

	Shader defaultPostProcessingShader = Shader(
		"#version 330 core\n"
		"\n"
		"layout(location = 0) in vec2 position;\n"
		"layout(location = 1) in vec2 uvCoord;\n"
		"\n"
		"out vec2 v_uvCoord;"
		"\n"
		"void main()\n"
		"{\n"
		"	gl_Position = vec4(position, 0, 1);\n"
		"	v_uvCoord = uvCoord;\n"
		"};\n"
		,
		"#version 330 core\n"
		"\n"
		"layout(location = 0) out vec4 color;\n"
		"\n"
		"in vec2 v_uvCoord;"
		"uniform sampler2D u_texture;"
		"\n"
		"void main()\n"
		"{\n"
		"	color = texture(u_texture, v_uvCoord);"
		"};\n"
	);

	Shader* postProcessingShader = nullptr;
};

#define window Window::getWindowInstance()